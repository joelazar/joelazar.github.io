[{"content":"Last week I made a âš¡ï¸ talk at Remix Copenhagen meetup. I thought I make a short blog post about the content if I already gather the material for it.\nThere is a mistake in this code. Can you find it? ğŸ” import type { Note } from \u0026#39;@prisma/client\u0026#39;; import { useCatch, useLoaderData } from \u0026#39;@remix-run/react\u0026#39;; import type { LoaderFunction } from \u0026#39;@remix-run/server-runtime\u0026#39;; import { json } from \u0026#39;@remix-run/server-runtime\u0026#39;; import { prisma } from \u0026#39;~/db.server\u0026#39;; /* export type Note = { id: string title: string body: string createdAt: Date updatedAt: Date } */ type LoaderData = { notes: Note[]; }; export const loader: LoaderFunction = async () =\u0026gt; { const notes = await prisma.note.findMany({}); return json({ notes }); }; export default function Problem() { const { notes } = useLoaderData\u0026lt;LoaderData\u0026gt;(); return ( \u0026lt;\u0026gt; {notes.map((note) =\u0026gt; ( \u0026lt;div key={note.id} className=\u0026#34;p flex flex-auto flex-col p-4 sm:p-6 lg:p-8\u0026#34; \u0026gt; \u0026lt;h2 className=\u0026#34;text-2xl font-bold\u0026#34;\u0026gt;{note.title}\u0026lt;/h2\u0026gt; \u0026lt;ul className=\u0026#34;text-lg\u0026#34;\u0026gt; \u0026lt;li\u0026gt; Created at: {Intl.DateTimeFormat(\u0026#39;en-US\u0026#39;).format(note.createdAt)} \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; Updated at: {Intl.DateTimeFormat(\u0026#39;en-US\u0026#39;).format(note.updatedAt)} \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Body: {note.body}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ))} \u0026lt;/\u0026gt; ); } âš ï¸ Solution The problem is with the following lines:\n\u0026lt;li\u0026gt; Created at: {Intl.DateTimeFormat(\u0026#34;en-US\u0026#34;).format(note.createdAt)} \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; Updated at: {Intl.DateTimeFormat(\u0026#34;en-US\u0026#34;).format(note.updatedAt)} \u0026lt;/li\u0026gt; Here, note.createdAt and note.updatedAt will have the type string instead of Date.\nExplanation ğŸ“œ At page navigation The client gets the code-split bundle for that page, and at time same time, the loader for that route gets evaluated, which is a Fetch request to the server. The response body of that request will be encoded in JSON, so it has to be serializable. Date and some other types don\u0026rsquo;t have a native JSON representation.\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ ğŸ–¥ï¸ â—„â”€â”€â”€code split bundleâ”€â”€â”€â”¤ â˜ï¸ â”‚ â”‚ browser â—„â”€â”€â”€data from loaderâ”€â”€â”€â”€â”¤ server â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ At full reload A full reload on the same route will do a full server render, and the data will be just embedded in the HTML. Loaders will be evaluated on the server side, but the data still has to be serializable there too.\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ ğŸ–¥ï¸ â—„â”€â”€â”€full code bundleâ”€â”€â”€â”€â”¤ â˜ï¸ â”‚ â”‚ browser â—„â”€â”€â”€â”€prefilled htmlâ”€â”€â”€â”€â”€â”¤ server â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ OK types âœ… string âœ… number âœ… boolean âœ… null âœ… Array âœ… Object Problematic types âŒ Date âŒ BigInt âŒ Set âŒ Map âŒ RegExp âŒ undefined âŒ Error âŒ NaN At least we get a linter warning since remix 1.6.5 How to solve it - stupid solution Convert the strings to Dates. For this type, it will work fine, as the Date\u0026rsquo;s constructor accepts strings:\n\u0026lt;li\u0026gt; Created at: {Intl.DateTimeFormat(\u0026#34;en-US\u0026#34;).format(new Date(note.createdAt))} \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; Updated at: {Intl.DateTimeFormat(\u0026#34;en-US\u0026#34;).format(new Date(note.updatedAt))} \u0026lt;/li\u0026gt; However, there are types in which this method won\u0026rsquo;t work. We need a more generic solution for this.\nHow to solve it - the proper solution New features since remix 1.6.5 \u0026ldquo;We enhanced the type signatures of loader and useLoaderData to make it possible to infer the data type from the return type of its related server function. To enable this feature, you will need to use the LoaderArgs type from your Remix runtime package instead of typing the function directly:\u0026rdquo;\nimport type { LoaderFunction } from \u0026#39;@remix-run/[runtime]\u0026#39;; // --\u0026gt; import type { LoaderArgs } from \u0026#39;@remix-run/[runtime]\u0026#39;; export const loader: LoaderFunction = async (args) =\u0026gt; { return json\u0026lt;LoaderData\u0026gt;(data); }; // --\u0026gt; export async function loader(args: LoaderArgs) { return json(data); } \u0026ldquo;Then you can infer the loader data by using typeof loader as the type variable in useLoaderData:\nlet data = useLoaderData() as LoaderData; // --\u0026gt; let data = useLoaderData\u0026lt;typeof loader\u0026gt;(); With this change, you no longer need to manually define a LoaderData type (huge time and typo saver!), and we serialize all values so that useLoaderData can\u0026rsquo;t return types that are impossible over the network, such as Date objects or functions.\u0026rdquo;\nReference: Remix 1.6.5 release note\nremix-typedjson Drop in replacement for useLoaderData/json calls \u0026ndash;\u0026gt; it will automatically convert your non-serializable types back and forth.\nconst loaderData = useLoaderData\u0026lt;typeof loader\u0026gt;(); // --\u0026gt; const loaderData = useTypedLoaderData\u0026lt;typeof loader\u0026gt;(); and\nreturn json({...}) // --\u0026gt; return typedjson({...}) Adding these two together:\nimport type { LoaderArgs } from \u0026#39;@remix-run/server-runtime\u0026#39;; import { typedjson, useTypedLoaderData } from \u0026#39;remix-typedjson\u0026#39;; import { prisma } from \u0026#39;~/db.server\u0026#39;; export const loader = async (_: LoaderArgs) =\u0026gt; { const notes = await prisma.note.findMany({}); return typedjson({ notes }); }; export default function Problem() { const { notes } = useTypedLoaderData\u0026lt;typeof loader\u0026gt;(); return ( \u0026lt;\u0026gt; {notes.map((note) =\u0026gt; ( \u0026lt;div key={note.id} className=\u0026#34;p flex flex-auto flex-col p-4 sm:p-6 lg:p-8\u0026#34; \u0026gt; \u0026lt;h2 className=\u0026#34;text-2xl font-bold \u0026#34;\u0026gt;{note.title}\u0026lt;/h2\u0026gt; \u0026lt;ul className=\u0026#34;text-lg\u0026#34;\u0026gt; \u0026lt;li\u0026gt; Created at: {Intl.DateTimeFormat(\u0026#39;en-US\u0026#39;).format(note.createdAt)} \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; Updated at: {Intl.DateTimeFormat(\u0026#39;en-US\u0026#39;).format(note.updatedAt)} \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Body: {note.body}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ))} \u0026lt;/\u0026gt; ); } This works now as we are sending a __meta__ object with the original JSON content, so on the client side the necessary data could be converted to the right type.\nWhat about other Remix API? Actions and fetchers are affected as well, but remix-typedjson handles them.\nconst actionData = useTypedActionData\u0026lt;typeof action\u0026gt;(); and\nconst fetcher = useTypedFetcher\u0026lt;typeof action\u0026gt;(); Could it be solved with superjson? Yes, of course.\nimport { deserialize, serialize } from \u0026#34;superjson\u0026#34;; ... export const loader: LoaderFunction = async () =\u0026gt; { const notes = await prisma.note.findMany({}); return json(serialize({ notes })); }; export default function Problem() { const { notes } = deserialize( useLoaderData() as SuperJSONResult ) as LoaderData; ... } However, remix-typesjson\u0026rsquo;s API is much more comfortable to use, not to mention that it\u0026rsquo;s faster and more lightweight than superjson.\nLink for the presentation and code examples.\n","permalink":"https://joelazar.github.io/posts/lost-in-translation/","summary":"Last week I made a âš¡ï¸ talk at Remix Copenhagen meetup. I thought I make a short blog post about the content if I already gather the material for it.\nThere is a mistake in this code. Can you find it? ğŸ” import type { Note } from \u0026#39;@prisma/client\u0026#39;; import { useCatch, useLoaderData } from \u0026#39;@remix-run/react\u0026#39;; import type { LoaderFunction } from \u0026#39;@remix-run/server-runtime\u0026#39;; import { json } from \u0026#39;@remix-run/server-runtime\u0026#39;; import { prisma } from \u0026#39;~/db.","title":"Lost in translation - Remix edition"},{"content":"Finally, I managed to update my dotfiles today and change for chezmoi for managing them properly. It took a bit of time, but I\u0026rsquo;m pleased with the result now. If you are interested, you can find them here.\n","permalink":"https://joelazar.github.io/posts/second-post/","summary":"Finally, I managed to update my dotfiles today and change for chezmoi for managing them properly. It took a bit of time, but I\u0026rsquo;m pleased with the result now. If you are interested, you can find them here.","title":"Refactored dotfiles"},{"content":"I guess my first post should be something funny so here is one pic of my sleeping dogs. I hope my next post will be something more useful though :)\n","permalink":"https://joelazar.github.io/posts/first-post-with-my-dogs/","summary":"I guess my first post should be something funny so here is one pic of my sleeping dogs. I hope my next post will be something more useful though :)","title":"My first post"}]